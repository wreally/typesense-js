{"version":3,"sources":["/home/fanis/code/typesense/fork/typesense-js/lib/Typesense.min.js","../src/Typesense/Logger.ts","../src/Typesense/Documents.ts","../src/Typesense/Overrides.ts"],"names":["LogLevelReverseMap","LogLevelNumber","logLevelToConsoleFunction","args","SimpleLogger","_SimpleLogger","level","message","isNodeJSEnvironment"],"mappings":"AAAA,qxBAAI,EAAE,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CCgD5F,IAAMA,EAAAA,CAAqB,CACzB,KAAA,CAAO,CAAA,CACP,KAAA,CAAO,CAAA,CACP,IAAA,CAAM,CAAA,CACN,IAAA,CAAM,CAAA,CACN,KAAA,CAAO,CAAA,CACP,MAAA,CAAQ,CACV,CAAA,CAUMC,CAAAA,CAAiB,CACrB,KAAA,CAAO,CAAA,CACP,KAAA,CAAO,CAAA,CACP,IAAA,CAAM,CAAA,CACN,IAAA,CAAM,CAAA,CACN,KAAA,CAAO,CAAA,CACP,MAAA,CAAQ,CACV,CAAA,CAiBA,IAAMC,EAAAA,CAA4B,CAChC,KAAA,CAAO,CAAA,GAAIC,CAAAA,CAAAA,EAAgB,OAAA,CAAQ,KAAA,CAAM,GAAGA,CAAI,CAAA,CAChD,KAAA,CAAO,CAAA,GAAIA,CAAAA,CAAAA,EAAgB,OAAA,CAAQ,KAAA,CAAM,GAAGA,CAAI,CAAA,CAChD,IAAA,CAAM,CAAA,GAAIA,CAAAA,CAAAA,EAAgB,OAAA,CAAQ,IAAA,CAAK,GAAGA,CAAI,CAAA,CAC9C,IAAA,CAAM,CAAA,GAAIA,CAAAA,CAAAA,EAAgB,OAAA,CAAQ,IAAA,CAAK,GAAGA,CAAI,CAAA,CAC9C,KAAA,CAAO,CAAA,GAAIA,CAAAA,CAAAA,EAAgB,OAAA,CAAQ,KAAA,CAAM,GAAGA,CAAI,CAAA,CAChD,MAAA,CAAQ,CAAA,CAAA,EAAM,CAAC,CACjB,CAAA,CAMMC,EAAAA,CAAN,MAAMC,CAAa,CAcT,WAAA,CAAA,CAAc,CANtB,IAAA,CAAQ,QAAA,CAAiCJ,CAAAA,CAAe,IAMjC,CAMvB,OAAO,WAAA,CAAA,CAA4B,CACjC,OAAKI,CAAAA,CAAa,QAAA,EAAA,CAChBA,CAAAA,CAAa,QAAA,CAAW,IAAIA,CAAAA,CAAAA,CAEvBA,CAAAA,CAAa,QACtB,CASQ,aAAA,CACNC,CAAAA,CACAC,CAAAA,CACQ,CACR,MAAO,CAAA,CAAA,EAAID,CAAK,CAAA,EAAA,EAAKC,CAAO,CAAA,CAAA;ACkNE;AAAA;AAAA;AAAA;AA4BnB,UAAA;AAoCUC;ACjXb","file":"/home/fanis/code/typesense/fork/typesense-js/lib/Typesense.min.js","sourcesContent":[null,"/**\n * Represents the log levels that can be used in the logger with their corresponding number values.\n */\ntype LogLevelMap = {\n  Trace: \"trace\" | 0;\n  Debug: \"debug\" | 1;\n  Info: \"info\" | 2;\n  Warn: \"warn\" | 3;\n  Error: \"error\" | 4;\n  Silent: \"silent\" | 5;\n};\n\n/**\n * Represents mapping of the number values of the log levels.\n */\ntype LogLevelNumberValuesMap = {\n  [K in keyof LogLevelMap]: LogLevelMap[K] extends infer R\n    ? R extends number\n      ? R\n      : never\n    : never;\n};\n\n/**\n * Numeric representation of the possible log levels.\n */\ntype LogLevelNumberValues =\n  LogLevelNumberValuesMap[keyof LogLevelNumberValuesMap];\n\n/**\n * Represents the mapping of the string values to the number values of the log levels.\n */\ntype StringToNumberRepresentationLogLevelMap = {\n  [K in keyof LogLevelMap as LogLevelMap[K] extends infer R\n    ? R extends string\n      ? R\n      : never\n    : never]: LogLevelMap[K] extends infer R\n    ? R extends number\n      ? R\n      : never\n    : never;\n};\n\n/**\n * Object that maps the log levels to their corresponding number values.\n * Used for always mapping the log level to number for comparison's sake.\n */\nconst LogLevelReverseMap = {\n  trace: 0,\n  debug: 1,\n  info: 2,\n  warn: 3,\n  error: 4,\n  silent: 5,\n} as const satisfies StringToNumberRepresentationLogLevelMap;\n\n/**\n * Represents the log levels that can be used in the logger.\n */\ntype LogLevel = LogLevelMap[keyof LogLevelMap];\n\n/**\n * Object that maps the log levels to their corresponding number values.\n */\nconst LogLevelNumber = {\n  Trace: 0,\n  Debug: 1,\n  Info: 2,\n  Warn: 3,\n  Error: 4,\n  Silent: 5,\n} as const satisfies { [K in keyof LogLevelMap]: LogLevelMap[K] };\n\n/**\n * Object that maps the log levels to their corresponding string values.\n */\nconst LogLevelNames = {\n  Trace: \"trace\",\n  Debug: \"debug\",\n  Info: \"info\",\n  Warn: \"warn\",\n  Error: \"error\",\n  Silent: \"silent\",\n} as const satisfies { [K in keyof LogLevelMap]: LogLevelMap[K] };\n\n/**\n * Object that maps the the console methods to the log levels.\n */\nconst logLevelToConsoleFunction = {\n  Trace: (...args: any[]) => console.trace(...args),\n  Debug: (...args: any[]) => console.debug(...args),\n  Info: (...args: any[]) => console.info(...args),\n  Warn: (...args: any[]) => console.warn(...args),\n  Error: (...args: any[]) => console.error(...args),\n  Silent: () => {},\n} as const satisfies { [K in keyof LogLevelMap]: (message: string) => void };\n\n/**\n * A simple logging class using a singleton pattern.\n * Only prints to stdout.\n */\nclass SimpleLogger {\n  private static instance: SimpleLogger;\n  /**\n   * Numeric representation of the log level set.\n   * Defaults to LogLevelNumber.Warn.\n   * @private\n   * @type {LogLevelNumberValues}\n   */\n  private logLevel: LogLevelNumberValues = LogLevelNumber.Warn;\n\n  /**\n   * Private constructor to prevent instantiation.\n   * @private\n   */\n  private constructor() {}\n\n  /**\n   * Get the singleton instance of the SimpleLogger.\n   * @returns {SimpleLogger} The singleton instance of the SimpleLogger.\n   */\n  static getInstance(): SimpleLogger {\n    if (!SimpleLogger.instance) {\n      SimpleLogger.instance = new SimpleLogger();\n    }\n    return SimpleLogger.instance;\n  }\n\n  /**\n   * Formats the message to be logged.\n   * @private\n   * @param level The log level to be used.\n   * @param message The message to be logged.\n   * @returns The formatted message.\n   */\n  private formatMessage(\n    level: keyof typeof LogLevelNames,\n    message: string,\n  ): string {\n    return `[${level}] ${message}`;\n  }\n\n  /**\n   * Logs the message with the appropriate console function\n   * @param level The log level to be used.\n   * @param message The message to be logged.\n   */\n  private logWith(level: keyof typeof LogLevelNames, message: string): void {\n    const consoleFunction = this.mapLogLevelToConsoleFunction(level);\n    consoleFunction(this.formatMessage(level, message));\n  }\n\n  /**\n   * Maps the log level to the appropriate console function.\n   * @param level The log level to be used.\n   * @returns The console function to be used for the log level.\n   */\n  private mapLogLevelToConsoleFunction(\n    level: keyof typeof LogLevelNames,\n  ): (message: string, ...args: any[]) => void {\n    return logLevelToConsoleFunction[level];\n  }\n\n  /**\n   * Uses the `console.debug` method to log the message if the log level is set to debug or lower.\n   * @param message The message to be logged.\n   */\n  debug(message: string): void {\n    if (this.logLevel <= LogLevelNumber.Debug) {\n      this.logWith(\"Debug\", message);\n    }\n  }\n\n  /**\n   * Uses the `console.warn` method to log the message if the log level is set to warn or lower.\n   * @param message The message to be logged.\n   */\n  warn(message: string): void {\n    if (this.logLevel <= LogLevelNumber.Warn) {\n      this.logWith(\"Warn\", message);\n    }\n  }\n\n  /**\n   * Uses the `console.error` method to log the message if the log level is set to error or lower.\n   * @param message The message to be logged.\n   */\n  error(message: string): void {\n    if (this.logLevel <= LogLevelNumber.Error) {\n      this.logWith(\"Error\", message);\n    }\n  }\n\n  /**\n   * Uses the `console.trace` method to log the message if the log level is set to trace or lower.\n   * @param message The message to be logged.\n   */\n  trace(message: string): void {\n    if (this.logLevel <= LogLevelNumber.Trace) {\n      this.logWith(\"Trace\", message);\n    }\n  }\n\n  /**\n   * Uses the `console.info` method to log the message if the log level is set to info or lower.\n   * @param message The message to be logged.\n   */\n  info(message: string): void {\n    if (this.logLevel <= LogLevelNumber.Info) {\n      this.logWith(\"Info\", message);\n    }\n  }\n\n  /**\n   * Sets the log level to the specified level as a numeric representation of it, if given a string.\n   * @param level The log level to be set.\n   */\n  setLogLevel(level: LogLevel): void {\n    if (typeof level === \"number\") {\n      this.logLevel = level;\n    } else {\n      this.logLevel = LogLevelReverseMap[level];\n    }\n  }\n}\n\nexport const logger = SimpleLogger.getInstance();\nexport type { LogLevel };\n","import type { ReadStream } from \"fs\";\nimport ApiCall from \"./ApiCall\";\nimport Configuration from \"./Configuration\";\nimport { ImportError } from \"./Errors\";\nimport { SearchOnlyDocuments } from \"./SearchOnlyDocuments\";\n\n// Todo: use generic to extract filter_by values\nexport interface DeleteQuery {\n  filter_by?: string;\n  batch_size?: number;\n  ignore_not_found?: boolean;\n}\n\nexport interface DeleteResponse {\n  num_deleted: number;\n}\n\ninterface ImportResponseSuccess {\n  success: true;\n}\n\nexport interface ImportResponseFail {\n  success: false;\n  error: string;\n  document: DocumentSchema;\n  code: number;\n}\n\nexport type ImportResponse = ImportResponseSuccess | ImportResponseFail;\n\nexport type DocumentSchema = Record<string, any>;\n\nexport interface SearchParamsWithPreset extends Partial<SearchParams> {\n  preset: string;\n}\n\ntype DropTokensMode =\n  | \"right_to_left\"\n  | \"left_to_right\"\n  | \"both_sides:3\";\n\ntype OperationMode = \"off\" | \"always\" | \"fallback\";\nexport interface SearchParams {\n  // From https://typesense.org/docs/latest/api/documents.html#arguments\n  q?: string;\n  query_by?: string | string[];\n  query_by_weights?: string | number[];\n  prefix?: string | boolean | boolean[]; // default: true\n  filter_by?: string;\n  enable_lazy_filter?: boolean; // default: false\n  sort_by?: string | string[]; // default: text match desc\n  facet_by?: string | string[];\n  max_facet_values?: number;\n  facet_sample_threshold?: number;\n  facet_sample_percent?: number;\n  facet_query?: string;\n  facet_query_num_typos?: number;\n  facet_return_parent?: string;\n  page?: number; // default: 1\n  per_page?: number; // default: 10, max 250\n  group_by?: string | string[];\n  group_limit?: number; // default:\n  group_missing_values?: boolean;\n  include_fields?: string | string[];\n  exclude_fields?: string | string[];\n  highlight_fields?: string | string[]; // default: all queried fields\n  highlight_full_fields?: string | string[]; // default: all fields\n  highlight_affix_num_tokens?: number; // default: 4\n  highlight_start_tag?: string; // default: <mark>\n  highlight_end_tag?: string; // default: </mark>\n  enable_highlight_v1?: boolean;\n  snippet_threshold?: number; // default: 30\n  num_typos?: string | number | number[]; // default: 2\n  min_len_1typo?: number;\n  min_len_2typo?: number;\n  split_join_tokens?: OperationMode;\n  exhaustive_search?: boolean;\n  drop_tokens_threshold?: number; // default: 10\n  drop_tokens_mode?: DropTokensMode;\n  typo_tokens_threshold?: number; // default: 100\n  pinned_hits?: string | string[];\n  hidden_hits?: string | string[];\n  limit_hits?: number; // default: no limit\n  pre_segmented_query?: boolean;\n  enable_overrides?: boolean;\n  override_tags?: string | string[];\n  prioritize_exact_match?: boolean; // default: true\n  prioritize_token_position?: boolean;\n  prioritize_num_matching_fields?: boolean;\n  search_cutoff_ms?: number;\n  use_cache?: boolean;\n  max_candidates?: number;\n  infix?: OperationMode | OperationMode[];\n  preset?: string;\n  text_match_type?: \"max_score\" | \"max_weight\";\n  vector_query?: string;\n  \"x-typesense-api-key\"?: string;\n  \"x-typesense-user-id\"?: string;\n  offset?: number;\n  limit?: number;\n  stopwords?: string;\n  conversation?: boolean;\n  conversation_model_id?: string;\n  conversation_id?: string;\n  voice_query?: string;\n}\n\ntype SearchResponseHighlightObject = {\n  matched_tokens?: string[];\n  snippet?: string;\n  value?: string;\n};\n\nexport type SearchResponseHighlight<T> = T extends string | number\n  ? SearchResponseHighlightObject\n  : {\n      [TAttribute in keyof T]?: SearchResponseHighlight<T[TAttribute]>;\n    };\n\nexport interface SearchResponseHit<T extends DocumentSchema> {\n  curated?: true;\n  highlights?: [\n    {\n      field: keyof T;\n      snippet?: string;\n      value?: string;\n      snippets?: string[];\n      indices?: number[];\n      matched_tokens: string[][] | string[];\n    },\n  ];\n  highlight: SearchResponseHighlight<T>;\n  document: T;\n  text_match: number;\n  text_match_info?: {\n    best_field_score: string; // To prevent scores from being truncated by JSON spec\n    best_field_weight: number;\n    fields_matched: number;\n    score: string; // To prevent scores from being truncated by JSON spec\n    tokens_matched: number;\n  };\n}\n\nexport interface SearchResponseFacetCountSchema<T extends DocumentSchema> {\n  counts: {\n    count: number;\n    highlighted: string;\n    value: string;\n  }[];\n  field_name: keyof T;\n  stats: {\n    avg?: number;\n    max?: number;\n    min?: number;\n    sum?: number;\n  };\n}\n\nexport interface SearchResponseRequestParams {\n  collection_name?: string;\n  q?: string;\n  page?: number;\n  per_page?: number;\n  first_q?: string;\n  voice_query?: {\n    transcribed_query?: string;\n  };\n}\n\n// Todo: we could infer whether this is a grouped response by adding the search params as a generic\nexport interface SearchResponse<T extends DocumentSchema> {\n  facet_counts?: SearchResponseFacetCountSchema<T>[];\n  found: number;\n  found_docs?: number;\n  out_of: number;\n  page: number;\n  request_params: SearchResponseRequestParams;\n  search_time_ms: number;\n  search_cutoff?: boolean;\n  hits?: SearchResponseHit<T>[];\n  grouped_hits?: {\n    group_key: string[];\n    hits: SearchResponseHit<T>[];\n    found?: number;\n  }[];\n  conversation?: {\n    answer: string;\n    conversation_history: {\n      conversation: object[];\n      id: string;\n      last_updated: number;\n      ttl: number;\n    };\n    conversation_id: string;\n    query: string;\n  };\n  error?: string;\n  code?: number;\n}\n\nexport interface DocumentWriteParameters {\n  dirty_values?: \"coerce_or_reject\" | \"coerce_or_drop\" | \"drop\" | \"reject\";\n  action?: \"create\" | \"update\" | \"upsert\" | \"emplace\";\n}\n\nexport interface UpdateByFilterParameters {\n  filter_by?: string;\n}\n\nexport interface UpdateByFilterResponse {\n  num_updated: number;\n}\n\nexport interface DocumentImportParameters extends DocumentWriteParameters {\n  batch_size?: number;\n  return_doc?: boolean;\n  return_id?: boolean;\n}\n\nexport interface DocumentsExportParameters {\n  filter_by?: string;\n  include_fields?: string;\n  exclude_fields?: string;\n}\n\nexport interface SearchableDocuments<T extends DocumentSchema> {\n  search(\n    searchParameters: SearchParams | SearchParamsWithPreset,\n    options: SearchOptions,\n  ): Promise<SearchResponse<T>>;\n  clearCache(): void;\n}\n\nexport interface WriteableDocuments<T> {\n  create(document: T, options: DocumentWriteParameters): Promise<T>;\n  upsert(document: T, options: DocumentWriteParameters): Promise<T>;\n  update(document: T, options: DocumentWriteParameters): Promise<T>;\n  delete(query: DeleteQuery): Promise<DeleteResponse>;\n  import(\n    documents: T[] | string,\n    options: DocumentWriteParameters,\n  ): Promise<string | ImportResponse[]>;\n  export(options: DocumentsExportParameters): Promise<string>;\n}\n\nexport interface SearchOptions {\n  cacheSearchResultsForSeconds?: number;\n  abortSignal?: AbortSignal | null;\n}\n\nconst isNodeJSEnvironment =\n  typeof process !== \"undefined\" &&\n  process.versions != null &&\n  process.versions.node != null;\n\nexport default class Documents<T extends DocumentSchema = object>\n  extends SearchOnlyDocuments<T>\n  implements WriteableDocuments<T>\n{\n  constructor(\n    collectionName: string,\n    apiCall: ApiCall,\n    configuration: Configuration,\n  ) {\n    super(collectionName, apiCall, configuration);\n  }\n\n  async create(document: T, options: DocumentWriteParameters = {}): Promise<T> {\n    if (!document) throw new Error(\"No document provided\");\n    return this.apiCall.post<T>(this.endpointPath(), document, options);\n  }\n\n  async upsert(document: T, options: DocumentWriteParameters = {}): Promise<T> {\n    if (!document) throw new Error(\"No document provided\");\n    return this.apiCall.post<T>(\n      this.endpointPath(),\n      document,\n      Object.assign({}, options, { action: \"upsert\" }),\n    );\n  }\n\n  async update(\n    document: T,\n    options: UpdateByFilterParameters,\n  ): Promise<UpdateByFilterResponse>;\n  async update(document: T, options: DocumentWriteParameters): Promise<T>;\n  async update(\n    document: T,\n    options: DocumentWriteParameters | UpdateByFilterParameters = {},\n  ): Promise<UpdateByFilterResponse | T> {\n    if (!document) throw new Error(\"No document provided\");\n\n    if (options[\"filter_by\"] != null) {\n      return this.apiCall.patch<T>(\n        this.endpointPath(),\n        document,\n        Object.assign({}, options),\n      );\n    } else {\n      return this.apiCall.post<T>(\n        this.endpointPath(),\n        document,\n        Object.assign({}, options, { action: \"update\" }),\n      );\n    }\n  }\n\n  async delete(\n    query: DeleteQuery = {} as DeleteQuery,\n  ): Promise<DeleteResponse> {\n    return this.apiCall.delete<DeleteResponse>(this.endpointPath(), query);\n  }\n\n  async createMany(documents: T[], options: DocumentImportParameters = {}) {\n    this.configuration.logger.warn(\n      \"createMany is deprecated and will be removed in a future version. Use import instead, which now takes both an array of documents or a JSONL string of documents\",\n    );\n    return this.import(documents, options);\n  }\n\n  /**\n   * Import a set of documents in a batch.\n   * @param {string|Array} documents - Can be a JSONL string of documents or an array of document objects.\n   * @param options\n   * @return {string|Array} Returns a JSONL string if the input was a JSONL string, otherwise it returns an array of results.\n   */\n  async import(\n    documents: string,\n    options?: DocumentImportParameters,\n  ): Promise<string>;\n  async import(\n    documents: T[],\n    options?: DocumentImportParameters,\n  ): Promise<ImportResponse[]>;\n  async import(\n    documents: T[] | string,\n    options: DocumentImportParameters = {},\n  ): Promise<string | ImportResponse[]> {\n    let documentsInJSONLFormat;\n    if (Array.isArray(documents)) {\n      try {\n        documentsInJSONLFormat = documents\n          .map((document) => JSON.stringify(document))\n          .join(\"\\n\");\n      } catch (error: any) {\n        // if rangeerror, throw custom error message\n        if (\n          error instanceof RangeError &&\n          error.message.includes(\"Too many properties to enumerate\")\n        ) {\n          throw new Error(`${error}\n          It looks like you have reached a Node.js limit that restricts the number of keys in an Object: https://stackoverflow.com/questions/9282869/are-there-limits-to-the-number-of-properties-in-a-javascript-object\n\n          Please try reducing the number of keys in your document, or using CURL to import your data.\n          `);\n        }\n\n        // else, throw the non-range error anyways\n        throw new Error(error);\n      }\n    } else {\n      documentsInJSONLFormat = documents;\n    }\n\n    const resultsInJSONLFormat = await this.apiCall.performRequest<string>(\n      \"post\",\n      this.endpointPath(\"import\"),\n      {\n        queryParameters: options,\n        bodyParameters: documentsInJSONLFormat,\n        additionalHeaders: { \"Content-Type\": \"text/plain\" },\n        skipConnectionTimeout: true, // We never want to client-side-timeout on an import and retry, since imports are syncronous and we want to let them take as long as it takes to complete fully\n        enableKeepAlive: isNodeJSEnvironment ? true : false, // This is to prevent ECONNRESET socket hang up errors. Reference: https://github.com/axios/axios/issues/2936#issuecomment-779439991\n      },\n    );\n\n    if (Array.isArray(documents)) {\n      const resultsInJSONFormat = resultsInJSONLFormat\n        .split(\"\\n\")\n        .map((r) => JSON.parse(r)) as ImportResponse[];\n      const failedItems = resultsInJSONFormat.filter(\n        (r) => r.success === false,\n      );\n      if (failedItems.length > 0) {\n        throw new ImportError(\n          `${\n            resultsInJSONFormat.length - failedItems.length\n          } documents imported successfully, ${\n            failedItems.length\n          } documents failed during import. Use \\`error.importResults\\` from the raised exception to get a detailed error reason for each document.`,\n          resultsInJSONFormat,\n        );\n      } else {\n        return resultsInJSONFormat;\n      }\n    } else {\n      return resultsInJSONLFormat as string;\n    }\n  }\n  /**\n   * Imports documents from a NodeJS readable stream of JSONL.\n   */\n  async importStream(\n    readableStream: ReadStream,\n    options: DocumentImportParameters = {},\n  ): Promise<ImportResponse[]> {\n    const resultsInJSONLFormat = await this.apiCall.performRequest<string>(\n      \"post\",\n      this.endpointPath(\"import\"),\n      {\n        queryParameters: options,\n        bodyParameters: readableStream,\n        additionalHeaders: { \"Content-Type\": \"text/plain\" },\n        skipConnectionTimeout: true, // We never want to client-side-timeout on an import and retry, since imports are syncronous and we want to let them take as long as it takes to complete fully\n        enableKeepAlive: isNodeJSEnvironment ? true : false, // This is to prevent ECONNRESET socket hang up errors. Reference: https://github.com/axios/axios/issues/2936#issuecomment-779439991\n      },\n    );\n\n    const resultsInJSONFormat = resultsInJSONLFormat\n      .split(\"\\n\")\n      .map((r) => JSON.parse(r)) as ImportResponse[];\n    const failedItems = resultsInJSONFormat.filter((r) => r.success === false);\n    if (failedItems.length > 0) {\n      throw new ImportError(\n        `${\n          resultsInJSONFormat.length - failedItems.length\n        } documents imported successfully, ${\n          failedItems.length\n        } documents failed during import. Use \\`error.importResults\\` from the raised exception to get a detailed error reason for each document.`,\n        resultsInJSONFormat,\n      );\n    } else {\n      return resultsInJSONFormat;\n    }\n  }\n\n  /**\n   * Returns a JSONL string for all the documents in this collection\n   */\n  async export(options: DocumentsExportParameters = {}): Promise<string> {\n    return this.apiCall.get<string>(this.endpointPath(\"export\"), options);\n  }\n\n  /**\n   * Returns a NodeJS readable stream of JSONL for all the documents in this collection.\n   */\n  async exportStream(\n    options: DocumentsExportParameters = {},\n  ): Promise<ReadStream> {\n    return this.apiCall.get<ReadStream>(this.endpointPath(\"export\"), options, {\n      responseType: \"stream\",\n    });\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport Collections from \"./Collections\";\nimport { OverrideSchema } from \"./Override\";\n\nconst RESOURCEPATH = \"/overrides\";\n\nexport interface OverrideRuleQuerySchema {\n  query?: string;\n  match?: \"exact\" | \"contains\";\n}\n\nexport interface OverrideRuleFilterSchema {\n  filter_by?: string;\n}\n\nexport interface OverrideRuleTagsSchema {\n  tags?: string[];\n}\n\nexport interface OverrideCreateSchema {\n  rule: OverrideRuleQuerySchema &\n    OverrideRuleFilterSchema &\n    OverrideRuleTagsSchema;\n  filter_by?: string;\n  sort_by?: string;\n  remove_matched_tokens?: boolean;\n  replace_query?: string;\n  includes?: Array<{\n    id: string;\n    position: number;\n  }>;\n  excludes?: Array<{ id: string }>;\n  filter_curated_hits?: boolean;\n  effective_from_ts?: number;\n  effective_to_ts?: number;\n  stop_processing?: boolean;\n  metadata?: object;\n}\n\nexport interface OverridesRetrieveSchema {\n  overrides: OverrideSchema[];\n}\n\nexport default class Overrides {\n  constructor(\n    private collectionName: string,\n    private apiCall: ApiCall,\n  ) {}\n\n  async upsert(\n    overrideId: string,\n    params: OverrideCreateSchema,\n  ): Promise<OverrideSchema> {\n    return this.apiCall.put<OverrideSchema>(\n      this.endpointPath(overrideId),\n      params,\n    );\n  }\n\n  async retrieve(): Promise<OverridesRetrieveSchema> {\n    return this.apiCall.get<OverridesRetrieveSchema>(this.endpointPath());\n  }\n\n  private endpointPath(operation?: string): string {\n    return `${Collections.RESOURCEPATH}/${this.collectionName}${\n      Overrides.RESOURCEPATH\n    }${operation === undefined ? \"\" : \"/\" + encodeURIComponent(operation)}`;\n  }\n\n  static get RESOURCEPATH(): string {\n    return RESOURCEPATH;\n  }\n}\n"]}